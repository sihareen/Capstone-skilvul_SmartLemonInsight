# -*- coding: utf-8 -*-
"""dlModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13GJSgQ7lpM7ej8JYeeOqDR7fYwtKtnJl

# Kampus Merdeka 6: IBM & Skilvul
# Artificial Intelligence Phase Challenge

## Kelompok: 39
## Anggota

*   Muhammad Rizkan Harin Faza
*   Dicky Wijaya Saputra
*   Nisrina Putri Fernanda Fairuz
*   Eko Santoso
*   Sukma Nurul

# Problem Definition
##Topik: Lemon Quality Control

## Latar Belakang
Sistem penentuan kualitas buah lemon berbasis CNN menawarkan solusi inovatif untuk mengatasi kelemahan quality control manual yang tradisional. Dengan kemampuannya untuk mengklasifikasikan kualitas lemon berdasarkan gambar dengan tingkat akurasi tinggi dan konsisten, sistem CNN dapat meningkatkan efisiensi, produktivitas, dan kualitas produk akhir dalam industri yang bergantung pada lemon. Hal ini berpotensi menghasilkan manfaat signifikan dalam hal pengurangan pemborosan, peningkatan profitabilitas, dan kepuasan konsumen.
## Tujuan Penelitian
Penelitian sistem penentuan kualitas buah lemon berbasis CNN bertujuan untuk:
  1. Mengembangkan model CNN yang akurat dan efisien untuk mengklasifikasikan kualitas buah lemon berdasarkan gambar.
  2. Menganalisis faktor-faktor yang mempengaruhi performa model CNN dalam mengklasifikasikan kualitas buah lemon.
  3. Mengembangkan sistem quality control buah lemon berbasis CNN yang terintegrasi dengan sistem otomasi.

## Pertanyaan kunci
1. Bagaimana cara merancang model CNN yang mampu mengklasifikasikan kualitas buah lemon dengan tingkat akurasi tinggi dan efisien?
2. Apa faktor-faktor yang paling signifikan dalam mempengaruhi performa model CNN dalam mengklasifikasikan kualitas buah lemon?
3. Bagaimana cara mengintegrasikan sistem quality control buah lemon berbasis CNN dengan sistem otomasi dan mengevaluasi performanya dalam lingkungan nyata?

## Data yang akan dipakai
(Nama : Lemon Quality Dataset| Sumber : kaggle| Deskripsi : Dataset ini merupakan kumpulan gambar Lemon yang telah disiapkan untuk menguji kualitas buah. Dataset ini berisi 2.533 gambar dengan 300 x 300 piksel yang terkandung dalam 3 kelas yaitu bad_quality, empty_background dan good_quality.)
## Jenis Masalah Neural Network
(Metode yang akan dipakai: Computer Vision (CV) )
## Model
(Model yang digunakan : CNN (Tensorflow))

# Preparation | Persiapan
## Import Libraries
"""

# import necessary packages
import numpy as np # linear algebra
import pandas as pd
import tensorflow as tf
from tensorflow.keras import models, layers
import matplotlib.pyplot as plt
import os

from google.colab import drive
drive.mount('/content/drive')

# #ambil model (opsional ketika dataset telah dilatih)
# from tensorflow.keras.models import load_model
# model = tf.keras.models.load_model("/content/drive/MyDrive/PRJ/savedModel/modelLemon1st.hdf5")

"""## Get Data | Mendapatkan Data"""

# get data
#df = pd.read_()
base_dir = ('/content/drive/MyDrive/PRJ/lemon_dataset')
!ls /content/drive/MyDrive/PRJ/lemon_dataset

"""## Explore Data (EDA) | Eksplorasi Data"""

# check data
for dirname, _, filenames in os.walk('/content/drive/MyDrive/PRJ/lemon_dataset/'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# describe data
image_size = 300
batch_size = 32
dataset = tf.keras.preprocessing.image_dataset_from_directory(
    '/content/drive/MyDrive/PRJ/lemon_dataset',
    shuffle=True,
    seed=123,
    image_size=(300, 300),
    batch_size=32
)

class_names = dataset.class_names
print(class_names)

#image labeling
for image_batch, label_batch in dataset.take(1):
     print(image_batch.shape)
     print(label_batch.numpy())

# perform data visualization
plt.figure(figsize=(10, 10))
for image_batch, labels_batch in dataset.take(1):
    for i in range(12):
        ax = plt.subplot(3, 4, i + 1)
        plt.imshow(image_batch[i].numpy().astype("uint8"))
        plt.title(class_names[labels_batch[i]])
        plt.axis("off")

"""## Preprocess Data | Proses Awal Data"""

# split data
def split_dataset(dataset, train_split= 0.8, test_split= 0.1, val_split= 0.1, shuffle=True, shuffle_size = 10000):
  assert (train_split+test_split+val_split) == 1
  ds_size = len(dataset)

  if shuffle:
    data = dataset.shuffle(shuffle_size, seed=12)

  train_size = int(ds_size*train_split)
  val_size = int(ds_size*val_split)

  train_ds = dataset.take(train_size)
  val_ds = dataset.skip(train_size).take(val_size)
  test_ds = dataset.skip(train_size).skip(val_size)

  return train_ds, test_ds, val_ds

train_ds, test_ds, val_ds = split_dataset(dataset)
train_ds = train_ds.cache().shuffle(10000).prefetch(buffer_size = tf.data.AUTOTUNE)
test_ds = test_ds.cache().shuffle(10000).prefetch(buffer_size = tf.data.AUTOTUNE)
val_ds = val_ds.cache().shuffle(10000).prefetch(buffer_size = tf.data.AUTOTUNE)

resize_and_rescale = tf.keras.Sequential([
    layers.Resizing(image_size, image_size),
    layers.Rescaling(1./299),
])

data_augmentation = tf.keras.Sequential([
    layers.RandomFlip("horizontal_and_vertical"),
    layers.RandomRotation(0.2),
])

train_ds = train_ds.map(
    lambda x, y: (data_augmentation(x, training=True), y)
).prefetch(buffer_size=tf.data.AUTOTUNE)
channel = 3
n_classes = 3

"""# Model Training | Pelatihan Model

Sesuai tujuan penelitian dan karakteristik data, 1 kelas algoritma CNN dari Tensorflow dipilih untuk dilatih dalam eksperimen dengan 4 Layer. Berikut adalah  algoritma dan layernya yang saya gunakan:

###* Sequential
- Conv2D
- MaxPooling2D
- Dense
- Flatten
"""

# build model
## set model type
input_shape = (batch_size, image_size, image_size, channel)
model = tf.keras.models.Sequential([
    resize_and_rescale,
    ## add layers
    layers.Conv2D(32, kernel_size = (3,3), activation = 'relu', input_shape = input_shape),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, kernel_size = (3,3), activation = 'relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, kernel_size = (3,3), activation = 'relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, kernel_size = (3,3), activation = 'relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, kernel_size = (3,3), activation = 'relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, kernel_size = (3,3), activation = 'relu'),
    layers.MaxPooling2D((2,2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(n_classes, activation='softmax'),
])
model.build(input_shape = input_shape)

# print model summary
model.summary()

# compile model
model.compile(
    loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),
    optimizer='adam',
    metrics=['accuracy']
    )

# fit / run model
history = model.fit(
    train_ds,
    batch_size = batch_size,
    validation_data = val_ds,
    verbose = 1,
    epochs = 30
)

"""# Model Evaluation | Evaluasi Model"""

# evaluate model
scores = model.evaluate(test_ds)
scores

#report evaluasi dan training
epochs = 30
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

plt.figure(figsize=(8, 8))
plt.subplot(1, 2, 1)
plt.plot(range(epochs), acc, label='Training Accuracy')
plt.plot(range(epochs), val_acc, label='Validation Accuracy')
plt.legend(loc='lower right')
plt.title('Training and Validation Accuracy')

plt.subplot(1, 2, 2)
plt.plot(range(epochs), loss, label='Training Loss')
plt.plot(range(epochs), val_loss, label='Validation Loss')
plt.legend(loc='lower right')
plt.title('Training and Validation Loss')

"""# Model Selection | Pemilihan Model

Berdasarkan hasil evaluasi ....., diputuskan untuk memilih model ..
"""

# save model
model.save ('/content/drive/MyDrive/PRJ/savedModel/modelLemon2nd.h5')

# testingModel (dengan input yang telah ditraining)
for images_batch, labels_batch in test_ds.take(1):
  first_image = images_batch[0].numpy().astype('uint8')
  first_label = labels_batch[0].numpy()
  print("first image to predict")
  plt.imshow(first_image)
  print("actual label", class_names[first_label])
  batch_prediction = model.predict(images_batch)
  print("predicted label", class_names[np.argmax(batch_prediction[0])])

# Testing model (dengan input diluar dataset)
in_img = tf.keras.preprocessing.image.load_img("/content/download (1).jpeg", target_size=(300, 300)) #masukan path gambar kesini
newImg = tf.keras.preprocessing.image.img_to_array(in_img)
newImg = np.expand_dims(newImg, axis=0)
prediksi = model.predict(newImg)
if prediksi[0][0] > 0.5:
    print("Lemon with bad quality")
elif prediksi[0][1] > 0.5:
    print("Lemon not detected")
else:
    print ("Lemon with good quality")
plt.imshow(in_img)

"""# Conclusion | Kesimpulan

1. Dataset yang kami gunakan yaitu memiliki 3 class (good_quality, bad_quality dan empty_background). Ketiga class tersebut digunakan untuk menjadi label yang dapat menentukan QC dari buah lemon
2. alasan mengapa kami menggunakan CNN dari TensorFlow untuk menentukan kualitas buah lemon:
    1. CNN telah terbukti sangat efektif dalam tugas pengolahan gambar, termasuk klasifikasi objek dan deteksi cacat.
    2. CNN mampu mengekstrak fitur kompleks dari gambar buah lemon, seperti tekstur, warna, dan bentuk, yang sulit diidentifikasi secara manual.
    3. CNN memungkinkan untuk menentukan kualitas buah lemon dengan tingkat akurasi yang tinggi, bahkan untuk buah lemon yang memiliki variasi bentuk, warna, dan tekstur.

   Berikut adalah model algoritma dan layer yang digunakan pada training model yang telah kami lakukan:
### Sequential
  - Conv2D
  - MaxPooling2D
  - Dense
  - Flatten

  Kemudian kami menggunakan ADAM (Adaptive Moment Estimation) sebagai optimizer pada saat compiling model dikarenakan ADAM memiliki efisiensi yang tinggi dan kinerja yang baik jika digunakan sebagai optimizer pada saat copiling model.
3. Metrik yang digunakan sebagai tolak ukur keberhasilan model adalah Akurasi (Accuracy). Hal ini diputuskan karena akurasi merupakan metrik paling dasar yang menghitung persentase prediksi yang benar dari suatu model dan akurasi yang tinggi menunjukkan bahwa model dapat memprediksi kualitas buah lemon dengan tepat.Iterasi yang digunakan adalah sebanyak 30x (30 epoch), dan didapatkan score model yang baik yaitu dengan nilai loss : **00.171%** dan accuracy : **98.96%**.

"""

#model structure
tf.keras.utils.plot_model(model, to_file='complex_model.png', show_shapes=True)